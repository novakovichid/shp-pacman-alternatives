Title,Body
Создание служебных каталогов,"**Описание.** При запуске приложения должны появляться каталоги `assets/` и `saves/`. **Шаги реализации:** - В `SpaceInvadersApplication` добавить инициализацию директорий до вызова UI. - Использовать `Path.mkdir(parents=True, exist_ok=True)` из `settings.py`. - Убедиться, что файл рекорда создаётся пустым при первом запуске. **Результат.** После `python main.py` создаются пустые каталоги и файл `saves/highscore.txt`."
Дополнение настроек игры,"**Описание.** Настройки должны описывать базовые параметры игрового процесса. **Шаги реализации:** - Добавить в `Settings` значение начальных жизней, длительность перезарядки, размеры объектов. - Вынести параметры волн (количество рядов, колонок, интервал опускания). - Обеспечить использование настроек в слоях core и services. **Результат.** Все магические числа вынесены в `Settings`, остальные модули их импортируют."
Обновление базового объекта,"**Описание.** Метод `GameObject.update` должен изменять позицию на основе скорости. **Шаги реализации:** - Добавить полям базовой скорости по осям X/Y. - Реализовать обновление координат с учётом `dt`. - Защитить объект от ухода за границы окна (через `Settings`). **Результат.** Любой наследник `GameObject` корректно смещается при вызове `update`."
Движение корабля игрока,"**Описание.** Реализовать методы `move_left` и `move_right` у `PlayerShip`. **Шаги реализации:** - Использовать скорость из настроек и временной шаг. - Ограничить перемещение рамками окна. - Вернуть из методов новое значение координаты или изменить поле `x` напрямую. **Результат.** Корабль игрока перемещается вдоль нижней границы без выхода за экран."
Создание снаряда,"**Описание.** Метод `PlayerShip.fire` должен создавать `Projectile` со стартовыми параметрами. **Шаги реализации:** - Учесть позицию корабля и направление вверх. - Устанавливать скорость из настроек и тип владельца `player`. - Сбрасывать перезарядку корабля. **Результат.** При вызове `fire` возвращается корректно инициализированный снаряд."
Продвижение снарядов,"**Описание.** Метод `Projectile.advance` отвечает за движение снаряда. **Шаги реализации:** - Обновлять координату `y` с учётом `velocity_y` и `dt`. - Возвращать флаг выхода за границы окна. - Использовать значение высоты окна из `Settings`. **Результат.** Снаряды двигаются по вертикали, их можно фильтровать по возвращаемому значению."
Управление волной врагов,"**Описание.** Методы `Wave.update` и `Wave.is_cleared` должны обрабатывать состояние врагов. **Шаги реализации:** - Смещать всех врагов по оси X, менять направление при достижении границ. - Опускать волну на `drop_distance` при смене направления. - Проверять, остались ли враги в списке. **Результат.** Волна корректно перемещается и сообщает об опустошении."
Инициализация игрового мира,"**Описание.** Реализовать `GameWorld.reset` и `GameWorld.spawn_wave`. **Шаги реализации:** - Сбрасывать счёт, уровень, жизни игрока. - Создавать корабль в центре, очищать списки снарядов. - Формировать волну врагов в виде сетки с шагом из настроек. **Результат.** При вызове `reset` игра возвращается в начальное состояние, волна появляется на верхней части экрана."
Очистка снарядов,"**Описание.** Метод `GameWorld.cleanup_projectiles` должен удалять вышедшие за экран снаряды. **Шаги реализации:** - Фильтровать список `projectiles`, оставляя только видимые объекты. - Возвращать количество удалённых снарядов (для статистики). - Учесть как снаряды игрока, так и врагов. **Результат.** После вызова метода в мире остаются только актуальные снаряды."
Запуск новой игры,"**Описание.** Метод `GameService.start_new_game` подготавливает мир и запускает цикл. **Шаги реализации:** - Вызывать `world.reset()` и `world.spawn_wave()`. - Сбрасывать служебные флаги `running`, `paused`. - Загружать рекорд через репозиторий. **Результат.** При запуске новая игра стартует с первой волны и чистым состоянием."
Обновление игрового цикла,"**Описание.** Метод `GameService.update` двигает объекты и обрабатывает события. **Шаги реализации:** - Пропускать обновление, если игра на паузе. - Обновлять игрока, врагов, снаряды с использованием `dt`. - Вызывать `handle_collisions`, `cleanup_projectiles`, проверять завершение волны. **Результат.** При регулярном вызове `update` состояние мира изменяется по игровым правилам."
Перемещение влево,"**Описание.** `GameService.move_player_left` вызывает движение игрока. **Шаги реализации:** - Делегировать вызов методу `PlayerShip.move_left`. - Учитывать состояние паузы и наличие игрока. - Обновлять данные HUD при необходимости. **Результат.** При нажатии соответствующей клавиши корабль двигается влево."
Перемещение вправо,"**Описание.** `GameService.move_player_right` зеркально реализует движение вправо. **Шаги реализации:** - Использовать метод `PlayerShip.move_right`. - Добавить защиту от выхода за границы. - Возвращать текущие координаты корабля для отладки. **Результат.** Корабль перемещается вправо в пределах окна."
Выстрел игрока,"**Описание.** Метод `GameService.player_fire` создаёт снаряд и добавляет его в мир. **Шаги реализации:** - Проверять перезарядку игрока. - Добавлять снаряд в список `world.projectiles`. - Воспроизводить звук выстрела (заглушка на этапе каркаса). **Результат.** При вызове метода появляется новый снаряд, готовый к обновлению."
Генерация волны врагов,"**Описание.** `GameService.spawn_enemy_wave` настраивает новую волну для текущего уровня. **Шаги реализации:** - Использовать параметры сложности из `Settings`. - Увеличивать скорость врагов с ростом уровня. - Сбрасывать таймер появления бонусных врагов. **Результат.** Каждая новая волна усложняется относительно предыдущей."
Обработка столкновений,"**Описание.** Метод `GameService.handle_collisions` фиксирует попадания и потери жизней. **Шаги реализации:** - Проверять пересечение прямоугольников игрока, врагов и снарядов. - Начислять очки при уничтожении врага, удалять объекты. - Уменьшать жизни игрока при попадании или столкновении. **Результат.** Коллизии корректно меняют состояние мира и счёт игрока."
Переключение паузы,"**Описание.** Реализовать `GameService.toggle_pause`. **Шаги реализации:** - Инвертировать флаг `paused`. - Останавливать и возобновлять расписанные таймеры pyglet. - Сообщать UI о текущем статусе паузы. **Результат.** Нажатие клавиши паузы приостанавливает и возобновляет игру."
Загрузка рекорда,"**Описание.** Метод `GameService.load_highscore` должен читать данные из репозитория. **Шаги реализации:** - Обратиться к `HighscoreRepository.load`. - Сохранять значение в поле сервиса. - Возвращать рекорд для отображения в HUD. **Результат.** При старте игры в сервисе доступно текущее значение рекорда."
Сохранение рекорда,"**Описание.** Метод `GameService.save_highscore` обновляет файл, если счёт выше рекорда. **Шаги реализации:** - Сравнить текущий счёт игрока с сохранённым рекордом. - При необходимости вызвать `HighscoreRepository.save`. - Обновить внутреннее поле рекорда. **Результат.** После окончания игры рекорд сохраняется и доступен при следующем запуске."
Регистрация ресурсов,"**Описание.** Класс `AssetManifest` должен хранить пути к изображениям и звукам. **Шаги реализации:** - Реализовать методы `register_image`, `register_sound`, `all_assets`. - Добавить загрузку данных из словаря или файла. - Передавать манифест в UI для отрисовки. **Результат.** Ресурсы централизованно описаны и доступны всем слоям."
Создание окна,"**Описание.** Метод `GameWindow.create_window` должен инициализировать `pyglet.window.Window`. **Шаги реализации:** - Использовать размеры из `Settings`. - Настроить заголовок окна и иконку. - Вызывать `bind_events` после создания. **Результат.** При запуске создаётся окно pyglet с заданными параметрами."
Привязка событий,"**Описание.** Метод `GameWindow.bind_events` регистрирует обработчики клавиш и отрисовки. **Шаги реализации:** - Использовать декораторы `@window.event` или `push_handlers`. - Реализовать обработку нажатий стрелок, пробела, Esc. - Добавить обработчик `on_draw`, который очищает экран и рисует HUD. **Результат.** Окно реагирует на ввод и готово к отрисовке кадра."
Планировщик обновлений,"**Описание.** Метод `GameWindow.schedule_updates` подключает игровой цикл к pyglet.clock. **Шаги реализации:** - Использовать `pyglet.clock.schedule_interval` с частотой из `Settings`. - Передавать `GameService.update` как коллбэк. - При паузе останавливать расписанный вызов. **Результат.** Игра обновляется каждые 1/60 секунды."
Запуск приложения,"**Описание.** Метод `GameWindow.run` запускает весь процесс. **Шаги реализации:** - Вызывать `create_window`, `schedule_updates`, `service.start_new_game`. - Запускать `pyglet.app.run()`. - Предусмотреть сохранение рекорда при выходе. **Результат.** `python main.py` открывает окно и запускает игру."
Экран окончания игры,"**Описание.** Добавить отображение финального экрана после потери всех жизней. **Шаги реализации:** - В сервисе отслеживать состояние игрока и вызывать колбэк UI при поражении. - В UI отображать сообщение, финальный счёт, кнопку рестарта. - После рестарта запускать `start_new_game`. **Результат.** После завершения игры пользователь видит экран с итогами и может начать заново."
