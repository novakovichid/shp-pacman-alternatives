Title,Description
Сцена с рекордами,"Добавить в приложение класс `HighscoreScene`, олицетворяющий сцену с таблицей рекордов.

Пока что сцена будет пустой.

Добавить эту сцену в приложение.

Переход со сцены меню на эту сцену должен производиться при нажатии по кнопки ""4"".

Реализовать в файле `scenes/highscore.py`.

Реализовать в ветке `feature/scenes/highscore`."
Интеграция таблицы рекордов,"1. Добавить в приложение объект класса `HighscoreTable`. Поместить его в класс `Settings`. 
2. Видоизменить строку создания объекта класса `HighscoreTableDrawer` так, чтобы исходными данными у него был объект класса `HighscoreTable`, созданный выше. Подкорректировать алгоритм отображения в случае, если структура данных внутри объекта не соответствует задуманной.

Реализовать в ветке `feature/highscore/integration`"
Оформление таблицы рекордов,"1. Перенести создание объекта класса `HighscoreTableDrawer` в класс сцены `HighscoreScene`.
2. Добавить на эту сцену кнопку ""Назад"". При нажатии кнопки - происходит переход на сцену с меню.
3. Реализовать в ветке `feature/scenes/highscore` (если она уже существует - можно использовать существующую, но нужно синхронизировать её с главной веткой разработки)"
Коллизия пакмана и стены,"Видоизменить код приложения так, чтобы при столкновении со стеной пакман останавливался.

Реализовать вызов обработчика коллизии нужно в методе `process_additional_logic` класса `GameScene` (куда перед этим нужно перенести пакмана и ячейку со стеной).

Реализовать в ветке `feature/collisions/pacman_wall`."
Коллизия пакмана и призрака,"Видоизменить код приложения так, чтобы при столкновении со призраком
- пакман останавливался
- в консоль выводилось сообщение ""съеден""

Реализовать вызов обработчика коллизии нужно в методе `process_additional_logic` класса `GameScene` (куда перед этим нужно перенести пакмана и любого из призраков).

Реализовать в ветке `feature/collisions/pacman_ghost`."
Определение направления движения призрака при коллизии со стеной,"Видоизменить код приложения так, чтобы при столкновении призрака и стены призрак изменял направление.

- Призрак не может после выбора направления идти вперёд (так как там стена)
- Призрак не может после выбора направления идти назад (так как призраки не могут по логике игры разворачиваться)*
- Среди оставшихся направлений - призрак может повернуть туда, где нет стены.
- И только в том случае, если спереди, справа и слева у призрака стены - тогда он может развернуться и пойти в обратную сторону.

Реализовать данную логику в классе `GhostWallDirectionChooser`. На вход классу подаётся поле, призрак и текущее положение призрака на поле. В результате работы основного метода этого класса - призрак должен изменить направление движения.

Реализовать вызов определителя направления нужно в методе `process_additional_logic` класса `GameScene` (куда перед этим нужно перенести синего призрака, если его там ещё нет).

Реализовать в ветке `feature/collisions/ghost_wall`."
Определение направления движения призрака на перекрёстке,"Видоизменить код приложения так, чтобы при нахождении на перекрёстке лабиринта призрак мог изменять направление.

Обычная клетка в лабиринте - клетка, из которой можно перейти в одном или двух направлениях (вперёд или назад)
Перекрёсток - клетка в лабиринте, из которой можно перейти в 3 или 4 направления.

При нахождении на перекрёстке, запускается алгоритм, который

- определит, в каких направлениях можно двигаться на перекрёстке
- исключит из направлений движеие ""назад"" относительно направления движения призрака.
- выберет случайное направление из оставшихся.

Реализовать данную логику в классе `GhostCrossDirectionChooser`. На вход классу подаётся поле, призрак и текущее положение призрака на поле. В результате работы основного метода этого класса - призрак должен изменить направление движения.

Реализовать вызов определителя направления нужно в методе `process_additional_logic` класса `GameScene` (куда перед этим нужно перенести синего призрака, если его там ещё нет).

Реализовать в ветке `feature/collisions/ghost_wall`."
Интеграция подсчёта количества жизней,"1. Добавить в приложение объект класса `LifeCount`. Поместить его в класс `Settings`.
2. Видоизменить строку создания объекта класса `LifeCountDrawer` так, чтобы исходными данными у него был объект класса `LifeCount`, созданный выше. Подкорректировать алгоритм отображения в случае, если структура данных внутри объекта не соответствует задуманной.

Реализовать в ветке `feature/life/integration`"
Отображение зёрен на поле,"Создать на игровой сцене объекты зёрен (как `Seed`, так и `Energzer`).

Поместить их в двумерный массив `self.seeds` (структура массива - эквивалентна полю)

Отобразить на экране так, чтобы все зёрна заняли свои места.

Реализоваать в ветке feature/field/seeds"
Коллизия пакмана и зерна,"Видоизменить код приложения так, чтобы при столкновении пакмана с зерном в консоль выводилось сообщение ""съел зерно"" или ""съел большое зерно"".

Реализовать вызов обработчика коллизии нужно в методе `process_additional_logic` класса `GameScene` (куда перед этим нужно перенести пакмана и два зерна).

Реализовать в ветке `feature/collisions/pacman_seed`."
